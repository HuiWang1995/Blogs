# RPC

## RPC框架有什么用

屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法；

隐藏底层网络通信的复杂性，让我们更专注于业务逻辑。

## RPC流程

![img](https://static001.geekbang.org/resource/image/ac/fa/acf53138659f4982bbef02acdd30f1fa.jpg)

## RPC协议

设计一个可扩展的RPC私有协议，RPC 更多的是负责应用间的通信，所以性能要求相对更高，且HTTP协议无状态。

## 序列化

jdk、json、hessian、Protobuf。

Protobuf 是 Google 公司内部的混合语言数据标准，是一种轻便、高效的结构化数据存储格式，可以用于结构化数据序列化。

![序列化协议重要性](https://static001.geekbang.org/resource/image/b4/a5/b42e44968c3fdcdfe2acf96377f5b2a5.jpg)

- 在使用 RPC 框架的过程中，我们构造入参、返回值对象，主要记住以下几点：
  - 对象要尽量简单，没有太多的依赖关系，属性不要太多，尽量高内聚；
  - 入参对象与返回值对象体积不要太大，更不要传太大的集合；
  - 尽量使用简单的、常用的、开发语言原生的对象，尤其是集合类；
  - 对象不要有复杂的继承关系，最好不要有父子类的情况。

## 网络通信

常见的网络 IO 模型分为四种：同步阻塞 IO（BIO）、同步非阻塞 IO（NIO）、IO 多路复用和异步非阻塞 IO（AIO）。在这四种 IO 模型中，只有 AIO 为异步 IO，其他都是同步 IO。

多路复用 IO 是在高并发场景中使用最为广泛的一种 IO 模型，如 Java 的 NIO、Redis、Nginx 的底层实现就是此类 IO 模型的应用，经典的 Reactor 模式也是基于此类 IO 模型。并且在 Linux 环境下，也要开启 epoll 来提升系统性能。

- 零拷贝

  缓冲区指向同一虚拟地址。

  ![img](https://static001.geekbang.org/resource/image/00/79/0017969e25ed01f650d7879ac0a2cc79.jpg)

  Netty 的 ByteBuffer 可以采用 Direct Buffers，使用堆外直接内存进行 Socket 的读写操作。

## 动态代理

- jdk动态代理

  Proxy.newProxyInstance

  ![img](https://static001.geekbang.org/resource/image/50/41/5042cf1b79e6b9233f2152e1e0aca741.jpg)

- 字节码

  Javassist、Byte Buddy 性能更好，不是反射调用。

## 架构组成

![img](https://static001.geekbang.org/resource/image/a3/a6/a3688580dccd3053fac8c0178cef4ba6.jpg)

### 服务发现

zk（CP）、消息总线（AP）。

### 健康检测

- 心跳机制
- 可用率
- 三种状态：健康状态，亚健康状态，死亡状态。（可否对标 正常、主观下线、客观下线）

### 路由策略

服务提供方更加灵活地管理、调用自己的流量，进一步降低上线可能导致的风险。

### 负载均衡

RPC 的负载均衡完全由 RPC 框架自身实现，RPC 的服务调用者会与“注册中心”下发的所有服务节点建立长连接，在每次发起 RPC 调用时，服务调用者都会通过配置的负载均衡插件，自主选择一个服务节点，发起 RPC 调用请求。

RPC 负载均衡策略一般包括随机权重、Hash、轮询、最短延迟。

- 智能负载均衡

  运行时状态指标收集器收集服务节点 CPU 核数、CPU 负载以及内存等指标，在服务调用者与服务提供者的心跳数据中获取。

  请求耗时指标收集器收集请求耗时数据，如平均耗时、TP99、TP999 等。

### 异常重试

这个机制是当调用端发起的请求失败时，如果配置了异常重试策略，RPC 框架会捕捉异常，对异常进行判定，符合条件则进行重试，重新发送请求。

在重试的过程中，为了能够在约定的时间内进行安全可靠地重试，在每次触发重试之前，我们需要先判定下这个请求是否已经超时，如果超时了会直接返回超时异常，否则我们需要重置下这个请求的超时时间，防止因多次重试导致这个请求的处理时间超过用户配置的超时时间，从而影响到业务处理的耗时。

在发起重试、负载均衡选择节点的时候，我们应该去掉重试之前出现过问题的那个节点，这样可以提高重试的成功率，并且我们允许用户配置可重试异常的白名单，这样可以让 RPC 框架的异常重试功能变得更加友好。

- 另外，在使用 RPC 框架的重试机制时，我们要确保被调用的服务的业务逻辑是幂等的，这样才能考虑是否使用重试，这一点至关重要。

### 优雅关闭

可以通过捕获操作系统的进程信号来获取，在 Java 语言里面，对应的是 Runtime.addShutdownHook 方法，可以注册关闭的钩子。在 RPC 启动的时候，我们提前注册关闭钩子，并在里面添加了两个处理程序，一个负责开启关闭标识，一个负责安全关闭服务对象，服务对象在关闭的时候会通知调用方下线节点。同时需要在我们调用链里面加上挡板处理器，当新的请求来的时候，会判断关闭标识，如果正在关闭，则抛出特定异常。

![img](https://static001.geekbang.org/resource/image/77/cc/7752081ec658f1d56ac4219f1c07fbcc.jpg)

### 优雅启动

<img src="https://static001.geekbang.org/resource/image/e7/d4/e796da8cf26f056479a59fd97b43d0d4.jpg" alt="img" style="zoom: 25%;" />

在加载的过程中，Spring 容器会顺序加载 Spring Bean，如果某个 Bean 是 RPC 服务的话，我们不光要把它注册到 Spring-BeanFactory 里面去，还要把这个 Bean 对应的接口注册到注册中心。

### 熔断限流

限流：计数器，还有可以做到平滑限流的滑动窗口、漏斗算法以及令牌桶算法等等。

熔断：调用端进行熔断保护自我。

降级：对不怎么重要的服务进行低优先级的处理。

### 隔离流量

分组：通过分组的方式隔离调用方的流量，从而避免因为一个调用方出现流量激增而影响其它调用方的可用率。

## 异步RPC

所谓的同步调用，不过是 RPC 框架在调用端的处理逻辑中主动执行了这个 Future 的 get 方法，让动态代理等待返回值；

而异步调用则是 RPC 框架没有主动执行这个 Future 的 get 方法，用户可以从请求上下文中得到这个 Future，自己决定什么时候执行这个 Future 的 get 方法。

CompletableFuture全异步

## 服务安全

- 授权平台（瓶颈点）

- 提供方校验

## 链路追踪

RPC 调用端在访问服务端时，在发送请求消息前会触发分布式跟踪埋点，在接收到服务端响应时，也会触发分布式跟踪埋点，并且在服务端也会有类似的埋点。这些埋点最终可以记录一个完整的 Span，而这个链路的源头会记录一个完整的 Trace，最终 Trace 信息会被上报给分布式链路跟踪系统。

## 时钟轮

时钟轮处理定时任务，避免线程扫描过多的任务，只需扫描对应槽位。

## 流量回放

应用引入了 RPC 后，所有的请求流量都会被 RPC 接管，所以我们可以很自然地在 RPC 里面支持流量回放功能。虽然这个功能本身并不是 RPC 的核心功能，但对于使用 RPC 的人来说，他们有了这个功能之后，就可以更放心地升级自己的应用了。

## 动态分组

我们只要把注册中心里面的部分实例的别名改成我们想要的别名，然后通过服务发现进而影响到不同调用方能够调用的服务提供方实例集合。

通过直接修改注册中心数据，我们可以让任何一个分组瞬间拥有不同规模的集群能力。我们不仅可以实现把某个实例的分组名改成另外一个分组名，还可以让某个实例分组名变成多个分组名，这就是我们在动态分组里面最常见的两种动作——追加和替换。

## 泛化调用

RPC 框架提供统一的泛化调用接口（GenericService），调用端在创建 GenericService 代理时指定真正需要调用的接口的接口名以及分组名，通过调用 GenericService 代理的 $invoke 方法将服务端所需要的所有信息，包括接口名、业务分组名、方法名以及参数信息等封装成请求消息，发送给服务端，实现在没有接口的情况下进行 RPC 调用的功能。

## 兼容多种RPC

<img src="https://static001.geekbang.org/resource/image/43/37/43451aea86fef673c3928230191fac37.jpg" alt="img" style="zoom: 25%;" />
